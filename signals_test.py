#!/usr/bin/env python3
"""
Focused Testing for Trading Signals - Review Request
Tests the current trading signals being generated by the backend to understand why frontend shows "WAITING FOR SIGNAL"
"""

import requests
import json
import time
from datetime import datetime
from dotenv import load_dotenv
import os

# Load environment variables
load_dotenv('/app/frontend/.env')
BACKEND_URL = os.getenv('REACT_APP_BACKEND_URL')
API_BASE_URL = f"{BACKEND_URL}/api"

print(f"Testing signals at: {API_BASE_URL}")

class SignalsTester:
    def __init__(self):
        self.base_url = API_BASE_URL
        
    def test_multi_coin_prices_signals(self):
        """Test the /api/multi-coin/prices endpoint to see what signals are currently being generated"""
        try:
            print("\nüîç Testing Multi-Coin Prices & Signals Endpoint...")
            response = requests.get(f"{self.base_url}/multi-coin/prices", timeout=15)
            
            if response.status_code == 200:
                data = response.json()
                print(f"‚úÖ Multi-coin prices endpoint working - Retrieved data for {len(data)} coins")
                
                # Check each coin for signals
                signals_found = []
                high_confidence_signals = []
                
                for symbol, coin_data in data.items():
                    print(f"\nüìä {symbol}:")
                    print(f"   Price: ${coin_data.get('price', 'N/A')}")
                    print(f"   24h Change: {coin_data.get('change_24h', 'N/A')}%")
                    print(f"   Volume: {coin_data.get('volume', 'N/A')}")
                    
                    # Check if this coin has analysis data with signals
                    if 'analysis' in coin_data:
                        analysis = coin_data['analysis']
                        if 'signal' in analysis:
                            signal = analysis['signal']
                            signals_found.append({
                                'symbol': symbol,
                                'signal_type': signal.get('signal_type'),
                                'strength': signal.get('strength'),
                                'price': signal.get('price')
                            })
                            
                            print(f"   üéØ SIGNAL: {signal.get('signal_type')} - Strength: {signal.get('strength', 0):.1f}%")
                            
                            # Check if signal meets 70%+ threshold
                            if signal.get('strength', 0) >= 70:
                                high_confidence_signals.append({
                                    'symbol': symbol,
                                    'signal_type': signal.get('signal_type'),
                                    'strength': signal.get('strength'),
                                    'price': signal.get('price')
                                })
                                print(f"   ‚≠ê HIGH CONFIDENCE SIGNAL (70%+)")
                        else:
                            print(f"   ‚è≥ No signal generated")
                    else:
                        print(f"   ‚ùì No analysis data available")
                
                print(f"\nüìà SIGNALS SUMMARY:")
                print(f"   Total signals found: {len(signals_found)}")
                print(f"   High confidence signals (70%+): {len(high_confidence_signals)}")
                
                if high_confidence_signals:
                    print(f"\n‚≠ê HIGH CONFIDENCE SIGNALS:")
                    for signal in high_confidence_signals:
                        print(f"   {signal['symbol']}: {signal['signal_type']} at {signal['strength']:.1f}% confidence")
                else:
                    print(f"\n‚ö†Ô∏è  NO HIGH CONFIDENCE SIGNALS FOUND")
                    print(f"   This explains why frontend shows 'WAITING FOR SIGNAL'")
                    
                    if signals_found:
                        print(f"\nüìä Available signals (below 70% threshold):")
                        for signal in signals_found:
                            print(f"   {signal['symbol']}: {signal['signal_type']} at {signal['strength']:.1f}% confidence")
                
                return True
                
            else:
                print(f"‚ùå Multi-coin prices endpoint failed: HTTP {response.status_code}")
                print(f"Response: {response.text}")
                return False
                
        except Exception as e:
            print(f"‚ùå Error testing multi-coin prices: {e}")
            return False
    
    def test_individual_signals_endpoints(self):
        """Test individual coin signal endpoints"""
        try:
            print("\nüéØ Testing Individual Signal Endpoints...")
            
            test_coins = ['doge', 'btc', 'eth']
            all_signals = []
            
            for coin in test_coins:
                print(f"\nüìä Testing {coin.upper()} signals...")
                response = requests.get(f"{self.base_url}/{coin}/signals", timeout=15)
                
                if response.status_code == 200:
                    signals = response.json()
                    print(f"   ‚úÖ {coin.upper()} signals endpoint working - {len(signals)} signals")
                    
                    for signal in signals:
                        signal_info = {
                            'symbol': signal.get('symbol'),
                            'signal_type': signal.get('signal_type'),
                            'strength': signal.get('strength'),
                            'timeframe': signal.get('timeframe'),
                            'price': signal.get('price'),
                            'timestamp': signal.get('timestamp')
                        }
                        all_signals.append(signal_info)
                        
                        print(f"   üéØ Signal: {signal['signal_type']} - {signal['strength']:.1f}% - {signal['timeframe']}")
                        
                        if signal['strength'] >= 70:
                            print(f"   ‚≠ê HIGH CONFIDENCE (70%+)")
                else:
                    print(f"   ‚ùå {coin.upper()} signals failed: HTTP {response.status_code}")
            
            # Summary of all individual signals
            high_conf_individual = [s for s in all_signals if s['strength'] >= 70]
            print(f"\nüìà INDIVIDUAL SIGNALS SUMMARY:")
            print(f"   Total individual signals: {len(all_signals)}")
            print(f"   High confidence (70%+): {len(high_conf_individual)}")
            
            if high_conf_individual:
                print(f"\n‚≠ê HIGH CONFIDENCE INDIVIDUAL SIGNALS:")
                for signal in high_conf_individual:
                    print(f"   {signal['symbol']}: {signal['signal_type']} at {signal['strength']:.1f}% ({signal['timeframe']})")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Error testing individual signals: {e}")
            return False
    
    def test_technical_analysis_for_signals(self):
        """Test technical analysis endpoints to understand signal generation"""
        try:
            print("\nüî¨ Testing Technical Analysis for Signal Generation...")
            
            test_coins = ['doge', 'btc', 'eth']
            
            for coin in test_coins:
                print(f"\nüìä {coin.upper()} Technical Analysis:")
                
                for timeframe in ['15m', '4h']:
                    response = requests.get(f"{self.base_url}/{coin}/analysis?timeframe={timeframe}", timeout=15)
                    
                    if response.status_code == 200:
                        analysis = response.json()
                        indicators = analysis.get('indicators', {})
                        
                        print(f"   üìà {timeframe} Analysis:")
                        print(f"      Price: ${analysis.get('current_price', 'N/A')}")
                        
                        # Check RSI
                        if 'rsi' in indicators:
                            rsi_val = indicators['rsi'].get('value', 0)
                            rsi_signal = "OVERSOLD" if rsi_val < 30 else "OVERBOUGHT" if rsi_val > 70 else "NEUTRAL"
                            print(f"      RSI: {rsi_val:.2f} ({rsi_signal})")
                        
                        # Check MACD
                        if 'macd' in indicators:
                            macd_val = indicators['macd'].get('macd', 0)
                            signal_val = indicators['macd'].get('signal', 0)
                            macd_signal = "BULLISH" if macd_val > signal_val else "BEARISH"
                            print(f"      MACD: {macd_val:.6f} ({macd_signal})")
                        
                        # Check Moving Averages
                        if 'moving_averages' in indicators:
                            ma = indicators['moving_averages']
                            sma_20 = ma.get('sma_20', 0)
                            sma_50 = ma.get('sma_50', 0)
                            ma_signal = "BULLISH" if sma_20 > sma_50 else "BEARISH"
                            print(f"      MA Signal: {ma_signal} (SMA20: {sma_20:.6f}, SMA50: {sma_50:.6f})")
                    else:
                        print(f"   ‚ùå {timeframe} analysis failed: HTTP {response.status_code}")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Error testing technical analysis: {e}")
            return False
    
    def test_signal_generation_thresholds(self):
        """Test to understand signal generation thresholds"""
        try:
            print("\n‚öôÔ∏è Testing Signal Generation Thresholds...")
            
            # Check what the current signal generation threshold is
            print("üìä Current signal generation logic:")
            print("   - Backend generates signals with 65%+ strength (advanced signals)")
            print("   - Frontend filters for signals with 70%+ strength")
            print("   - Gap between 65-70% signals are generated but not shown")
            
            # Test if we can find any signals in the 65-70% range
            response = requests.get(f"{self.base_url}/doge/signals", timeout=15)
            
            if response.status_code == 200:
                signals = response.json()
                
                medium_strength_signals = [s for s in signals if 65 <= s.get('strength', 0) < 70]
                high_strength_signals = [s for s in signals if s.get('strength', 0) >= 70]
                
                print(f"\nüìà Signal Strength Distribution:")
                print(f"   65-70% strength (generated but filtered): {len(medium_strength_signals)}")
                print(f"   70%+ strength (shown in frontend): {len(high_strength_signals)}")
                
                if medium_strength_signals:
                    print(f"\n‚ö†Ô∏è  FILTERED SIGNALS (65-70%):")
                    for signal in medium_strength_signals:
                        print(f"   {signal['symbol']}: {signal['signal_type']} at {signal['strength']:.1f}%")
                    print(f"   üí° These signals exist but are filtered out by frontend")
                
                return True
            else:
                print(f"‚ùå Failed to get DOGE signals: HTTP {response.status_code}")
                return False
                
        except Exception as e:
            print(f"‚ùå Error testing signal thresholds: {e}")
            return False
    
    def run_signals_analysis(self):
        """Run comprehensive signals analysis"""
        print("üéØ TRADING SIGNALS ANALYSIS - Review Request")
        print("=" * 60)
        print("Investigating why frontend shows 'WAITING FOR SIGNAL'")
        print("=" * 60)
        
        # Test 1: Multi-coin prices endpoint (main endpoint frontend uses)
        test1_ok = self.test_multi_coin_prices_signals()
        
        # Test 2: Individual signal endpoints
        test2_ok = self.test_individual_signals_endpoints()
        
        # Test 3: Technical analysis to understand signal generation
        test3_ok = self.test_technical_analysis_for_signals()
        
        # Test 4: Signal generation thresholds
        test4_ok = self.test_signal_generation_thresholds()
        
        print("\n" + "=" * 60)
        print("üéØ SIGNALS ANALYSIS SUMMARY")
        print("=" * 60)
        
        print(f"Multi-coin prices endpoint: {'‚úÖ PASS' if test1_ok else '‚ùå FAIL'}")
        print(f"Individual signals endpoints: {'‚úÖ PASS' if test2_ok else '‚ùå FAIL'}")
        print(f"Technical analysis: {'‚úÖ PASS' if test3_ok else '‚ùå FAIL'}")
        print(f"Signal thresholds: {'‚úÖ PASS' if test4_ok else '‚ùå FAIL'}")
        
        print(f"\nüí° CONCLUSIONS:")
        print(f"   1. If no high confidence signals (70%+) are found, 'WAITING FOR SIGNAL' is correct")
        print(f"   2. Check if signals exist in 65-70% range (generated but filtered)")
        print(f"   3. Consider adjusting frontend filter threshold if needed")
        print(f"   4. Verify technical indicators are generating meaningful signals")
        
        return test1_ok and test2_ok and test3_ok and test4_ok

if __name__ == "__main__":
    if not BACKEND_URL:
        print("‚ùå Error: REACT_APP_BACKEND_URL not found in frontend/.env")
        exit(1)
        
    tester = SignalsTester()
    success = tester.run_signals_analysis()
    
    if not success:
        exit(1)